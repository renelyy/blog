# HTTP 常见面试题

## 1. 如何理解 OSI 七层模型？

> OSI 七层模型（OSI Reference Model）是开放系统互联（Open Systems Interconnection）的缩写，是一个<b>分层的网络架构模型，用于描述和标准化网络通信</b>。它将网络通信分为七个不同的层次，每一层都有特定的功能和服务。通过这种分层结构，可以使不同的网络设备和协议能够互相通信。

1. <b>应用层</b>（Application Layer）

   - 功能：提供网络服务和应用接口，直接与用户交互。常见的协议和服务包括 `HTTP`、`FTP`、`SMTP` 等。
   - 设备：通常在软件中实现，不需要特殊硬件设备。

2. <b>表示层</b>（Presentation Layer）

   - 功能：负责数据的格式化和翻译，处理数据加密、解密、压缩、解压缩等。它确保不同系统之间的数据可以互相理解。
   - 设备：通常在软件中实现，不需要特殊硬件设备。

3. <b>会话层</b>（Session Layer）

   - 功能：管理和控制应用程序之间的对话（会话），建立、维护和终止会话，支持对话的同步和恢复。
   - 设备：通常在软件中实现，不需要特殊硬件设备。

4. <b>传输层</b>（Transport Layer）

   - 功能：提供端到端的可靠数据传输服务，负责分段和重组、流量控制、错误检测与恢复。常用协议包括 `TCP` 和 `UDP`。
   - 设备：通常在软件中实现，不需要特殊硬件设备。

5. <b>网络层</b>（Network Layer）

   - 功能：负责数据包的路由选择和转发，通过 IP 地址进行逻辑寻址，决定数据包的路径。
   - 设备：路由器（Router）。

6. <b>数据链路层</b>（Data Link Layer）

   - 功能：提供点到点的数据传输，负责帧的组装和拆解、物理地址（MAC 地址）的管理、错误检测和纠正。
   - 设备：交换机（Switch）、网桥（Bridge）、网卡（Network Interface Card）。

7. <b>物理层</b>（Physical Layer）

   - 功能：负责实际的物理连接，传输原始的比特流（0 和 1），包括硬件设备（如电缆、光纤、交换机、网卡等）的规范。

   - 设备：集线器（Hub）、中继器（Repeater）、网络电缆。

::: tip
通过这个分层模型，OSI 模型帮助开发人员和网络工程师理解和设计复杂的网络架构，确保不同厂商的设备和协议能够互操作。<b>每一层都依赖于下一层的服务，并为上一层提供服务，这种分层设计使得网络系统更加模块化和灵活</b>。
:::

## 2. 如何理解 TCP/IP 协议？

> TCP/IP 协议（Transmission Control Protocol/Internet Protocol）是一套广泛使用的网络通信协议，用于连接互联网上的设备。它由多个层次的协议组成，通过分层模型实现数据传输。虽然与 OSI 七层模型有相似之处，但 TCP/IP 模型更简化，通常分为四层。

::: warning 注意

`TCP/IP` 协议不仅仅指的是 `TCP`(传输控制协议) 和 `IP`(网际协议) 两个协议，而是指一个由 `FTP`、`SMTP`、`TCP`、`UDP`、`IP` 等协议构成的协议簇

:::

1. <b>应用层</b>（Application Layer）

   - 功能：提供网络服务和应用接口，直接与用户交互。每种应用都有自己的协议。
   - 协议：

     - `HTTP`（Hypertext Transfer Protocol）：用于 Web 浏览。
     - `FTP`（File Transfer Protocol）：用于文件传输。
     - `SMTP`（Simple Mail Transfer Protocol）：用于电子邮件传输。
     - `DNS`（Domain Name System）：用于域名解析。

   - 设备：通常在软件中实现，不需要特殊硬件设备。

2. <b>传输层</b>（Transport Layer）

   - 功能：提供端到端的可靠数据传输服务，负责数据段的分组和重组、流量控制、错误检测与恢复。
   - 协议：
     - `TCP`（Transmission Control Protocol）：<b>提供可靠的、面向连接的</b>传输，确保数据的完整性和顺序。
     - `UDP`（User Datagram Protocol）：<b>提供不可靠的、无连接的</b>传输，适用于对速度要求高、但对可靠性要求低的应用。
   - 设备：通常在软件中实现，不需要特殊硬件设备。

3. <b>网络层</b>（Internet Layer）

   - 功能：负责数据包的路由选择和转发，通过 IP 地址进行逻辑寻址，决定数据包的路径，提供跨越多个网络的数据传输。
   - 协议：
     - `IP`（Internet Protocol）：负责数据包的寻址和路由。
     - `ICMP`（Internet Control Message Protocol）：用于发送错误报告和网络诊断（如 ping）。
     - `ARP`（Address Resolution Protocol）：用于将 IP 地址解析为物理地址（MAC 地址）。
   - 设备：路由器

4. <b>链路层</b>（Link Layer）

   - 功能：负责设备之间的数据传输，定义了在本地网络上如何使用物理介质传输数据，包括硬件地址（MAC 地址）的管理、帧的组装和拆解。
   - 协议：以太网（Ethernet）、Wi-Fi 等。
   - 设备：网卡、交换机、集线器。

::: tip TCP/IP 模型与 OSI 模型的比较

> TCP/IP 模型与 OSI 模型的层次划分不同，但功能上有相似之处：

- 应用层：OSI 模型的应用层、表示层、会话层在 TCP/IP 模型中合并为应用层。
- 传输层：两者都包含传输层，负责端到端的通信。
- 网络层：OSI 模型的网络层对应于 TCP/IP 模型的网络层。
- 链路层：OSI 模型的物理层和数据链路层在 TCP/IP 模型中合并为链路层。

:::

::: tip 总结
TCP/IP 协议是互联网通信的基础，通过其四个层次模型，实现了不同网络设备和应用之间的数据传输。其分层设计使得网络通信更具模块化和灵活性，每一层都有特定的协议和功能，确保数据能够可靠、有效地传输。
:::

## 3. 如何理解 UDP 和 TCP？区别？应用场景？

> TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）是两个最常用的传输层协议，它们在数据传输过程中有不同的特点和应用场景。

1. <b>`TCP`</b>（传输控制协议）

   - 特点：
     - <b>面向连接</b>：TCP 在发送数据之前必须建立连接（通过三次握手）。
     - <b>可靠传输</b>：通过确认机制、重传机制和流量控制，TCP 提供可靠的数据传输，确保数据包按顺序且无误地到达接收方。
     - <b>流量控制</b>：通过滑动窗口机制，控制发送和接收数据的速率，避免拥塞。
     - <b>拥塞控制</b>：通过慢开始、拥塞避免、快速重传和快速恢复机制，避免网络拥塞。
     - <b>数据流管理</b>：TCP 将数据流分成多个段，并确保这些段按顺序到达接收方。
   - 应用场景：适用于<b>对数据传输可靠性要求高</b>的应用，如文件传输(`FTP`)、电子邮件(`SMTP`, `IMAP`, `POP3`)、Web 浏览(`HTTP`, `HTTPS`)、远程连接(`SSH`, `Telnet`)等。

2. <b>`UDP`</b>（用户数据报协议）

   - 特点：
     - <b>无连接</b>：数据传输不需要建立连接，适用于对实时性要求高、对可靠性要求低的应用。
     - <b>不可靠传输</b>：不保证数据的完整性和顺序，不提供确认机制、重传机制和流量控制，数据包可能丢失、重复或乱序到达接收方。。
     - <b>简单高效/低延迟</b>：没有复杂的控制机制，传输速度快，传输延迟较低，适用于实时性要求高的应用，如视频会议、在线游戏等。
     - <b>数据报文</b>：UDP 将数据分成独立的报文，每个报文包含完整的数据单元。
   - 应用场景：适用于<b>对实时性要求高</b>、对可靠性要求低的应用，如实时音视频会议、在线游戏、实时聊天、直播流媒体、网络广播或多播（例如 DHCP 和 DNS 查询）等。

3. 区别
   | 特性 | TCP | UDP |
   | :--: | :--: | :--: |
   | 连接类型 | 面向连接 | 无连接 |
   | 传输可靠性 | 可靠传输，确保数据包顺序且无误到达 | 不可靠传输，数据包可能丢失、重复或乱序 |
   | 流量控制 | 流量控制，滑动窗口机制 | 无 |
   | 拥塞控制 | 拥塞控制，慢开始、拥塞避免、快重传、快恢复 | 无 |
   | 传输速度 | 较慢，由于建立连接和可靠性开销 | 较慢，由于无连接和无可靠性开销 |
   | 数据传输单位 | 数据流 | 数据报文 |
   | 头部开销 | 较高（20 字节） | 较低（8 字节） |
   | 应用场景 | 对数据传输可靠性要求高的应用 | 对实时性要求高、对可靠性要求低的应用 |

::: tip 总结
TCP 和 UDP 是两种不同的传输层协议，它们在数据传输过程中有不同的特点和应用场景。TCP 提供可靠的数据传输，适用于对数据传输可靠性要求高的应用，而 UDP 则适用于对实时性要求高、对可靠性要求低的应用。选择哪种协议取决于具体的应用需求。
:::

## 4. 说一下 GET 和 POST 的区别？

1. <b>数据传输方式</b>：

   - GET：将数据附加在 URL 后面，通过查询字符串的形式进行传递。
   - POST：将数据放在请求体中，通过 HTTP 请求体进行传递。

2. <b>数据大小限制</b>：

   - GET：URL 有长度限制，通常为 `2048` 个字符，因此数据大小有限制。
   - POST：数据大小没有限制，取决于服务器的配置。

3. <b>安全性</b>：

   - GET：数据在 URL 中可见，容易被记录在浏览器历史记录或服务器日志中，不安全，不适合传递敏感信息。
   - POST：数据在请求体中，不易被记录，相对安全，但仍需使用 `HTTPS` 确保数据传输的安全性。

4. <b>缓存</b>：

   - GET：浏览器主动缓存。
   - POST：不会被浏览器主动缓存，除非手动设置。

5. <b>幂等性</b>：

   - GET：幂等操作，多次请求结果相同，不会对服务器资源进行修改。
   - POST：非幂等操作，多次请求结果可能不同，例如多次提交表单可能会创建多个资源。

6. <b>用途</b>：

   - GET：通常用于获取数据，如查询、搜索等。
   - POST：通常用于提交数据，如表单提交、文件上传等。

7. <b>参数位置</b>：

   - GET 参数包含在 URL 中，作为查询字符串的一部分。例如：`http://example.com/api/resource?param1=value1&param2=value2`。
   - POST 参数包含在请求体（body）中

8. <b>数据包</b>：

   - GET 浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）。
   - POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200（返回数据）。

   ::: warning 注意
   并不是所有浏览器都会在 POST 请求中发送两次请求，有些浏览器可能会在第一次请求中发送所有数据，而有些服务器可能会在收到第一次请求后立即响应，而不需要等待第二次请求。Firefox 就只发送一次。
   :::

::: tip 总结
GET 和 POST 是两种常见的 HTTP 请求方法，它们在数据传输方式、数据大小限制、安全性、缓存、幂等性和用途等方面有所不同。在选择使用哪种方法时，应根据数据的传输方式、数据量、安全性需求等因素进行权衡。
:::

## 5. 说说 TCP 为什么需要三次握手和四次挥手？

> TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的协议，为了确保数据的可靠传输，需要进行连接的建立和终止。TCP 的三次握手和四次挥手过程确保了通信双方都能可靠地建立和终止连接。

1.  三次握手（Three-Way Handshake）

    三次握手其实就是在建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。目的是建立可靠的 TCP 连接，<b>确保双方都有能力发送和接收数据、指定自己的初始化序列号为后面的可靠性传输做准备</b>。具体步骤如下：

    - 第一次握手：

      - 客户端发送一个带有 SYN 标志位的 TCP 报文段给服务器，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态。
      - SYN（Synchronize Sequence Numbers）表示请求建立连接。

    - 第二次握手：

      - 服务器收到客户端的 SYN 报文段，会以自己的 SYN 报文应答，为了确认客户端的 SYN，将客户端的 ISN + 1 作为 ACK 的值，此时服务器属于 SYN_RCVD 的状态。

    - 第三次握手：

      - 客户端收到服务器的 SYN + ACK 报文段，会发送一个 ACK 报文，值为服务器的 ISN + 1。此时客户端处于 ESTABLISHED 状态，服务器收到 ACK 报文后也处于 ESTABLISHED 状态，连接建立成功。

::: warning 为什么不是两次握手？

- 如果是两次握手，<b>服务器无法确认客户端的接收能力</b>（客户端是否已经准备好接收数据）。

:::

2.  四次挥手（Four-Way Handshake）

    四次挥手的目的是可靠地终止 TCP 连接，确保双方都能正确地完成数据传输并关闭连接。具体步骤如下：

    - 第一次挥手：

      - 客户端发送一个带有 FIN 标志位的 TCP 报文段给服务器，表示客户端要终止连接。
      - FIN（Finish）表示发送方没有数据要发送了，但仍然可以接收数据。

    - 第二次挥手：

      - 服务器收到客户端的 FIN 报文段，确认请求。
      - 服务器发送一个带有 ACK 标志位的 TCP 报文段给客户端，确认客户端的 FIN，即 ACK = 客户端的序列号 + 1。
      - 此时，客户端到服务器的数据传输方向已经关闭，服务器仍然可以发送数据到客户端。

    - 第三次挥手：

      - 服务器准备终止连接，发送一个带有 FIN 标志位的 TCP 报文段给客户端。
      - 服务器告知客户端没有数据要发送了。

    - 第四次挥手：

      - 客户端收到服务器的 FIN 报文段，确认请求。
      - 客户端发送一个带有 ACK 标志位的 TCP 报文段给服务器，确认服务器的 FIN，即 ACK = 服务器的序列号 + 1。
      - 客户端等待一段时间（通常是 2 倍的最大报文段寿命，称为 TIME-WAIT 状态）以确保服务器收到 ACK 报文段，然后关闭连接。

::: tip 总结
TCP 的三次握手和四次挥手过程确保了通信双方都能可靠地建立和终止连接。三次握手确保双方都有能力发送和接收数据，四次挥手确保双方都能正确地完成数据传输并关闭连接。
:::

## 6. 说说 HTTP 常见的请求头有哪些？作用？

> HTTP 请求头是客户端向服务器发送请求时附带的键值对信息，用于传递关于客户端、资源和请求本身的额外信息。

### 常见请求头

1. `Host`

   - 作用：指定请求的目标主机和端口。
   - 示例：`Host: www.example.com:80`

2. `User-Agent`

   - 作用：标识客户端浏览器的类型、版本和操作系统等信息。
   - 示例：`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3`

3. `Accept`

   - 作用：指定客户端能够接收的内容类型。
   - 示例：`Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8`

4. `Accept-Language`

   - 作用：指定客户端能够接收的自然语言。
   - 示例：`Accept-Language: en-US,en;q=0.5`

5. `Accept-Encoding`

   - 作用：指定客户端能够接收的内容编码。
   - 示例：`Accept-Encoding: gzip, deflate`

6. `Cookie`

   - 作用：携带客户端的 Cookie 信息，用于身份验证和状态管理。
   - 示例：`Cookie: sessionId=12345; user=JohnDoe`

7. `Authorization`

   - 作用：提供 HTTP 认证信息，用于身份验证。
   - 示例：`Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=`

8. `Referer`

   - 作用：指定请求的来源页面。
   - 示例：`Referer: https://www.example.com/page1`

9. `Connection`

   - 作用：控制当前连接的持久性。
   - 示例：`Connection: keep-alive`

10. `Cache-Control`

    - 作用：指定缓存指令，用于控制缓存行为。
    - 示例：`Cache-Control: no-cache`

11. `Content-Type`

    - 作用：指定请求体的媒体类型。
    - 示例：`Content-Type: application/json`

12. `Content-Length`

    - 作用：指定请求体的长度。
    - 示例：`Content-Length: 123`

13. `Origin`

    - 作用：指定请求的来源域。
    - 示例：`Origin: https://www.example.com`

14. `If-Modified-Since`

    - 作用：指定请求的资源在指定时间之后是否被修改。
    - 示例：`If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT`

15. `If-None-Match`
    - 作用：指定请求的资源与指定的 ETag 值是否匹配。
    - 示例：`If-None-Match: "123456789"`

### 使用场景

::: tip 提示
通过使用请求头和响应头的相关字段，可以满足一些场景，例如身份验证、缓存控制、内容协商等。
:::

1. 协商缓存
   - `If-Modified-Since` 和 `If-None-Match` 用于协商缓存，客户端可以通过这两个请求头向服务器发送上次请求时返回的 ETag 或 Last-Modified 值，服务器根据这些值判断资源是否被修改，如果没有修改则返回 304 状态码，否则返回新的资源。
2. 内容协商
   - `Accept`、`Accept-Language` 和 `Accept-Encoding` 用于内容协商，客户端可以通过这些请求头向服务器发送自己能够接收的内容类型、语言和编码，服务器根据这些信息返回最合适的内容。
3. 身份验证
   - `Authorization` 用于身份验证，客户端可以通过这个请求头向服务器发送身份验证信息，例如用户名和密码的 Base64 编码。
4. 缓存控制
   - `Cache-Control` 用于缓存控制，客户端可以通过这个请求头向服务器发送缓存指令，例如 `no-cache` 每次请求都要向服务器验证资源的有效性（通常通过发送 `If-None-Match` 或 `If-Modified-Since` 头信息来实现，如果服务器确认资源没有更改，它会返回 304 Not Modified 状态码，并且不需要重新传输资源内容，这样可以节省带宽），no-store：不缓存任何响应数据，`max-age=3600` 表示缓存有效期为 3600 秒。
5. 跨域请求
   - `Origin` 用于跨域请求，客户端可以通过这个请求头向服务器发送请求的来源域，服务器可以根据这个信息判断是否允许跨域请求。
6. 请求体
   - `Content-Type` 和 `Content-Length` 用于指定请求体的媒体类型和长度，客户端可以通过这些请求头向服务器发送请求体，例如 POST 请求的表单数据或 JSON 数据。

### 总结

HTTP 请求头和响应头是 HTTP 协议的重要组成部分，它们用于传递客户端和服务器之间的元数据，例如<b>身份验证</b>、<b>缓存控制</b>、<b>内容协商</b>等。通过使用这些请求头和响应头，可以满足各种场景的需求，提高 HTTP 通信的效率和安全性。

## 7. 说说 HTTP 常见的状态码有哪些，适用场景？

> HTTP 状态码是服务器在响应客户端请求时返回的数字代码，用于表示请求的处理结果。状态码由三位数字组成，其中第一位数字表示状态码的类型。

### 常见状态码

1. `1xx（信息性状态码）`
   - 100 Continue：客户端应继续发送请求的剩余部分。
   - 101 Switching Protocols：服务器已切换协议，例如从 HTTP/1.1 切换到 WebSocket。
2. `2xx（成功状态码）`
   - `200 OK`：请求成功，服务器返回请求的资源。这是最常见的成功状态码。
   - 201 Created：请求成功，并且服务器创建了新的资源。
   - 202 Accepted：请求已接受，但服务器尚未处理完成。
   - 204 No Content：请求成功，但服务器没有返回任何内容。
3. `3xx（重定向状态码）`
   - `301 Moved Permanently`：请求的资源已被永久移动到新的位置，客户端应使用新的 URL 访问资源。
   - 302 Found：请求的资源临时移动到新的位置，客户端应使用新的 URL 访问资源。
   - `304 Not Modified`：请求的资源未修改，客户端可以使用缓存的版本。
4. `4xx（客户端错误状态码）`
   - 400 Bad Request：请求无效，服务器无法理解请求的内容。
   - `401 Unauthorized`：请求需要身份验证，客户端应提供有效的身份验证信息。
   - 403 Forbidden：服务器拒绝请求，通常是因为权限不足。
   - `404 Not Found`：请求的资源不存在。
   - 405 Method Not Allowed：请求的方法不允许，例如 GET 请求的 URL 上定义了 POST 方法。
   - 406 Not Acceptable：服务器无法根据客户端的请求返回合适的内容。
   - 408 Request Timeout：请求超时。
5. `5xx（服务器错误状态码）`
   - `500 Internal Server Error`：服务器内部错误，服务器无法完成请求。
   - 501 Not Implemented：服务器不支持请求的功能。
   - 502 Bad Gateway：服务器作为网关或代理时，从上游服务器接收到的响应无效。
   - 503 Service Unavailable：服务器暂时无法处理请求，通常是因为服务器过载或维护。
   - 504 Gateway Timeout：服务器作为网关或代理时，未能及时从上游服务器接收响应。

::: tip 总结
HTTP 状态码用于表示 HTTP 请求的处理结果，常见的状态码包括 1xx、2xx、3xx、4xx 和 5xx。其中，`1xx` 表示`信息性状态码`，`2xx` 表示`成功状态码`，`3xx` 表示`重定向状态码`，`4xx` 表示`客户端错误状态码`，`5xx` 表示`服务器错误状态码`。
:::

## 8. 什么是 HTTP？HTTP 和 HTTPS 的区别？

::: tip 什么是 HTTP

HTTP（HyperText Transfer Protocol，超文本传输协议）是用于在 Web 浏览器和服务器之间传输数据的应用层协议。

:::

::: tip 和 HTTPS 的区别

1. 数据传输的安全性
2. 身份验证
3. 端口号
4. 性能
5. SEO 优势：https 有利于 SEO，搜索引擎更倾向于排名较高的 https 网站

:::

## 9. 说说 HTTP1.0/1.1/2.0 的区别？

::: tip 总结

1. HTTP 1.0：每个请求/响应都会关闭连接，不支持持久连接，缓存机制简单。
2. HTTP 1.1：默认启用持久连接，支持请求管线化，增强缓存机制，引入分块传输编码和部分内容请求。
3. HTTP/2：采用二进制传输，支持多路复用、头部压缩、服务器推送和请求优先级排序，大大提高了传输效率和性能。

:::

### 1. HTTP 1.0

1. 发布年份：1996 年
2. 主要特性：
   - `每个请求/响应独立`：每次请求/响应后，TCP 连接会关闭。每个新的请求都需要重新建立连接，这导致了大量的开销。
   - `不支持持久连接`：每个资源的获取都需要独立的连接，导致网络资源的浪费和延迟。
   - `基本缓存机制`：支持简单的缓存机制，通过头部字段 Expires 实现。

### 2. HTTP 1.1

1. 发布年份：1997 年
2. 主要特性：
   - `持久连接`：默认启用持久连接（Connection: keep-alive），允许在一个 TCP 连接上进行多个请求/响应，减少了连接建立和关闭的开销。
   - `请求管线化`：允许客户端在等待第一个请求的响应时发送多个请求，服务器可以按照顺序处理这些请求，提高了请求的并发性。
   - `增强的缓存机制`：引入了 Cache-Control 等头部字段，提供了更灵活的缓存控制机制。
   - `分块传输编码`：允许服务器动态生成内容，并使用 Transfer-Encoding 头部字段将内容分成多个块进行传输。
   - `部分内容请求`：通过 Range 头部字段，允许客户端请求资源的部分内容，服务器返回状态码 206 Partial Content 和请求的部分内容。

### 3. HTTP/2

1. 发布年份：2015 年
2. 主要特性：
   - `二进制传输`：HTTP/2 使用二进制格式进行数据传输，而不是文本格式，提高了传输效率和解析速度。
   - `多路复用`：允许在一个 TCP 连接上同时进行多个请求和响应，避免了 HTTP/1.1 中的队头阻塞问题。
   - `头部压缩`：使用 HPACK 压缩算法对头部字段进行压缩，减少了传输头部字段的开销。
   - `服务器推送`：服务器可以在客户端请求之前主动推送资源，减少了请求的延迟和带宽消耗。
   - `请求优先级`：允许客户端指定请求的优先级，服务器可以根据优先级处理请求，提高了关键资源的加载速度。

## 10. 为什么说 HTTPS 比 HTTP 安全？HTTPS 是如何保证安全的？

::: tip 为什么安全？

1. HTTP 通信使用明文传输，内容可能被窃听和篡改，且不验证通信方的身份，可能遭遇伪装，导致中间人攻击
2. HTTPS 比 HTTP 更安全，因为它使用 SSL/TLS 协议对数据进行加密，确保数据在传输过程中不会被窃取或篡改。HTTPS 还通过数字证书验证服务器身份，防止中间人攻击，并提供数据完整性校验，确保数据没有被篡改。

:::

::: tip 如何保证安全？
HTTPS 通过以下方式保证安全：

<b>加密通信</b>：客户端和服务器通过 SSL/TLS 握手过程，协商生成对称加密的会话密钥，用于之后的加密通信。

<b>数据完整性校验</b>：通过消息认证码（MAC）或哈希函数对数据进行校验，确保数据在传输过程中没有被篡改。

<b>身份验证</b>：数字证书由受信任的证书颁发机构（CA）签发，客户端通过验证证书来确认服务器的身份，防止中间人攻击。
:::

## 11. 如何理解 CDN？说说实现原理？

::: tip 如何理解

CDN（Content Delivery Network，内容分发网络）是一种分布式网络架构，旨在通过将内容分发到全球各地的多个服务器节点上，提高内容访问速度和可靠性。CDN 的主要目标是减少用户访问内容的延迟，提升网站的性能和可用性。

:::

::: tip 实现原理

CDN 的主要原理是通过全球分布的边缘节点将内容缓存和分发给用户，以减少延迟、提高访问速度和可靠性。CDN 利用智能路由、负载均衡、协议优化和安全防护等技术，实现了高效的内容传输和网站性能优化。

:::

## 12. DNS 协议是什么？说说 DNS 完整的查询过程？

::: tip 是什么

DNS（Domain Name System，域名系统）是一种用于将人类易读的域名（如 www.example.com）转换为机器可读的 IP 地址（如 192.0.2.1）的系统和协议。DNS 协议是应用层协议，基于 UDP 和 TCP 端口 53 运行，负责将域名解析为 IP 地址，以便客户端可以通过 IP 地址与服务器通信。

:::

::: tip 完整查询过程

1. 客户端发起查询 -> 查看浏览器缓存 -> 操作系统缓存
2. 本地域名服务器 -> `递归`查询缓存
3. 向上级域名服务器`迭代`查询
   - 本地域名服务器 -> 根域名服务器 -> 返回顶级域名服务器的地址
   - 本地域名服务器 -> 顶级域名服务器 -> 返回权威域名服务器的地址
   - 本地域名服务器 -> 权威 DNS 服务器 -> 返回 IP 地址
4. 本地域名服务器将返回 IP 地址返回给操作系统，同时自己缓存
5. 操作系统将 IP 地址返回给浏览器，同时自己缓存
6. 浏览器得到 IP 地址，并将 IP 地址缓存
7. 浏览器开始与服务器通信

:::

## 13. 说说对 WebSocket 的理解？应用场景？

::: tip 什么是 WebSocket?

WebSocket 是一种网络通信协议，设计用于在客户端和服务器之间建立持久连接，允许双向数据传输。与传统的 HTTP 协议不同，WebSocket 可以在一个连接上进行`全双工通信`，这意味着客户端和服务器都可以随时发送和接收数据，而不需要像 HTTP 那样频繁地建立和关闭连接。

:::

1. 主要特性

   - `全双工通信`：客户端和服务器可以同时发送和接收数据，而不需要像 HTTP 那样频繁地建立和关闭连接。
   - `实时性`：WebSocket 支持实时数据传输，可以用于实时聊天、在线游戏、实时数据监控等场景。
   - `低延迟`：由于 WebSocket 使用持久连接，减少了连接建立和关闭的开销，降低了延迟。

2. 应用场景
   - `实时聊天`：WebSocket 可以用于实现实时聊天功能，如在线聊天室、即时通讯等。
   - `在线游戏`：WebSocket 可以用于实现实时在线游戏，如多人在线游戏、实时对战游戏等。
   - `实时数据监控`：WebSocket 可以用于实时监控数据，如股票行情、实时监控设备状态等。
   - `实时通知`：WebSocket 可以用于实时通知，如实时消息推送、实时通知提醒等。

## 14. 说说地址栏输入 URL 敲下回车后发生了什么？

1. 简单回答：

   `URL 解析 -> DNS 查询 -> TCP 连接 -> HTTP 请求 -> 响应请求 -> 页面渲染`

2. 深入回答：

   - <b>URL 解析：浏览器解析 URL</b>
     1. 首先判断输入的是一个合法的 URL 还是一个待搜索的关键字
     2. 获取协议、域名、端口、路径、查询字符串等信息
   - <b>DNS 查询：浏览器根据域名查找对应的 IP 地址</b>

     首先，浏览器需要将用户输入的 URL 转换为服务器的 IP 地址，这一步是通过 DNS 解析完成的。

     - 检查本地缓存：浏览器首先检查本地缓存是否有该域名的解析记录。
     - 操作系统缓存：如果本地缓存没有找到，浏览器会请求操作系统查看是否有缓存。
     - 路由器缓存：如果操作系统缓存中也没有，操作系统会向路由器请求解析记录。
     - ISP DNS 缓存：如果路由器缓存也没有，路由器会向 ISP 的 DNS 服务器请求解析。
     - 递归查询：如果 ISP 的 DNS 服务器也没有记录，它会进行递归查询，逐级查询根域名服务器、顶级域名服务器（如 .com 服务器）、权威 DNS 服务器，最终得到 IP 地址。

   - <b>TCP 连接：浏览器与服务器建立 TCP 连接，进行三次握手。</b>

     获取到 IP 地址后，浏览器需要与服务器建立 TCP 连接。这包括以下几个步骤：

     - 三次握手：通过三次握手建立可靠的 TCP 连接：
     - 客户端发送 SYN 包（同步序列编号）请求与服务器建立连接。
     - 服务器接收到请求后，回应一个 SYN-ACK 包（同步确认）。
     - 客户端接收到回应后，再次发送一个 ACK 包（确认），连接建立。

   - <b>HTTP 请求：浏览器发送 HTTP 请求给服务器，服务器返回响应。</b>

     TCP 连接建立后，浏览器会发送一个 HTTP 请求到服务器。这个请求包括：

     - 请求行：包括请求方法（GET、POST 等）、请求 URL 和 HTTP 版本。
     - 请求头：包括浏览器信息、接受的内容类型、cookie 等。
     - 请求体（仅 POST 等方法）：包括提交的数据。

   - <b>响应请求：浏览器解析响应。</b>

     服务器接收到请求后，会进行处理，并返回一个 HTTP 响应。这个响应包括：

     - 状态行：包括 HTTP 版本、状态码（如 200、404）和状态描述。
     - 响应头：包括内容类型、内容长度、服务器信息等。
     - 响应体：包括实际的网页内容（HTML、CSS、JavaScript 等）。

   - <b>页面渲染：浏览器渲染页面。</b>

     浏览器接收到服务器的响应后，会开始渲染页面，过程包括：

     - 解析 HTML：从上到下解析 HTML 文件，构建 DOM 树。
     - 解析 CSS：同时解析 CSS 文件，构建 CSSOM 树，并与 DOM 树结合形成渲染树。
     - 解析 JavaScript：遇到 script 标签时，解析并执行 JavaScript 代码，可能会修改 DOM 树或 CSSOM 树。
     - 布局和绘制：根据渲染树计算每个元素的布局位置，并将内容绘制到屏幕上。

   - <b>加载资源</b>

     在解析 HTML 的过程中，浏览器会发现其他资源（如图片、视频、CSS、JavaScript 文件等）的 URL，并发起额外的 HTTP 请求来获取这些资源。

   - <b>执行 JavaScript</b>

     JavaScript 文件下载并解析后，会根据脚本中的逻辑执行相应的操作，如动态更新页面内容、发送异步请求等。

   - <b>事件处理</b>

     页面加载完成后，浏览器进入事件循环，处理用户交互（如点击、输入等）和其他事件（如定时器、网络请求完成等）。

## 15. 说说对 HTTP 缓存的了解？缓存头有哪些？

### 强缓存和协商缓存

1. 强缓存（强制缓存）：

   - 浏览器直接使用缓存的内容，而不会向服务器发送请求来验证内容的有效性。
   - 通过 `Expires` 和 `Cache-Control` 头字段实现。

1. 协商缓存（对比缓存）：

   - 浏览器向服务器发送请求并验证缓存的内容是否仍然有效。如果有效，服务器返回 304 Not Modified 状态码，浏览器继续使用缓存内容。
   - 通过 `Last-Modified`、` If-Modified-Since``、ETag ` 和 `If-None-Match` 头字段实现。

### 缓存头字段

1. `Expires`

   - 指定资源过期的日期和时间。
   - 格式：Expires: Wed, 21 Oct 2023 07:28:00 GMT
   - 缺点：由于依赖客户端时间，如果客户端时间不准确，缓存可能会失效。

2. `Cache-Control`

   - 更加灵活和强大的缓存控制方式，替代了 Expires。
   - 常见指令：
     - public: 可以被任何缓存存储。
     - private: 只能被单个用户缓存（即客户端），不能被共享缓存（如代理服务器）缓存。
     - no-cache: 每次使用缓存前都必须向服务器进行验证。
     - no-store: 不允许缓存，每次都从服务器获取资源。
     - max-age=[seconds]: 缓存内容在指定时间内有效。
     - s-maxage=[seconds]: 适用于共享缓存（如 CDN），优先级高于 max-age。

3. `Last-Modified`

   - 资源最后修改的时间。
   - 格式：Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT

4. `If-Modified-Since`

   - 客户端通过此头字段向服务器发送请求，询问自指定时间后资源是否被修改。
   - 格式：If-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT
   - 服务器对比资源的 Last-Modified 时间，如果没有修改，则返回 304 状态码。

5. `ETag`
   - 资源的唯一标识符（实体标签），由服务器生成。
   - 格式：ETag: "abc123"
   - 更加精确地验证资源的修改情况。
6. `If-None-Match`
   - 客户端通过此头字段向服务器发送请求，询问资源的 ETag 是否匹配。
   - 格式：If-None-Match: "abc123"
   - 服务器对比资源的 ETag 值，如果匹配，则返回 304 状态码。
